#!/usr/bin/perl

$TL_VERSION="0.1f";
$debug=0;

use LC::log; 
use LC::config;
use LC::UI;
use LC::parse;
use LC::Expand;
use LC::gag;
use LC::Command;
use LC::User;
use Socket;
use Fcntl;
use IO::Socket;
use IO::Select;
use Curses;
use POSIX;
$|=1;

# globals
$have_pseudo=0;
$last_alarm=0;
$next_alarm=0;
$wakeup=10;     # how often to exit the select loop to do status processing,
                # etc.
$password_mode=0;

## main ##


LC::config::init();
exp_init();
ui_start();
gag_init();
cmd_init();
user_init();

ui_attr('sender','bold');
ui_attr('dest','bold');
ui_attr('b','bold');
if (! $config{mono}) {
    ui_attr('status_line',  'fg:yellow',  'bg:blue',  'bold');
    ui_attr('input_line',   'fg:white',   'bg:black', 'bold');
    ui_attr('text_window',  'fg:white',   'bg:black', 'normal');
    ui_attr('privhdr',      'fg:green',   'bg:black');
    ui_attr('privmsg',      'fg:green',   'bg:black');
    ui_attr('pubhdr',       'fg:cyan',    'bg:black');
    ui_attr('pubmsg',       'fg:white',   'bg:black');
    ui_attr('emote',        'fg:cyan',    'bg:black');
    ui_attr('review',       'fg:magenta', 'bg:black');
    ui_attr('usersend',     'fg:red',     'bg:black');
    #ui_attr('time',         'fg:magenta', 'bg:black',  'bold');
    ui_attr('whiteblue',    'fg:white',   'bg:blue');
    ui_attr('greenblue',    'fg:green',   'bg:blue',  'bold');
    ui_attr('yellow',       'fg:yellow',  'bg:black',  'bold');
    ui_attr('green',        'fg:green',   'bg:black',  'bold');
} else {
    ui_attr('status_line', 'reverse');
}

tie $page_status, 'LC::status_update', 'page_status';

my $state;

main();


log_notice("Exiting.");

END {
    ui_end;
}

##############################################################################
sub server_connect ($$) {
    my($host, $port) = @_;

    log_notice("Connecting to $config{server} $config{port}.");
    $sock = IO::Socket::INET->new(PeerAddr => $config{server},
				  PeerPort => $config{port},
				  Proto    => 'tcp');                         
    if (!defined($sock)) {
	die "Failed to contact server.\n$1\n";
    }

    fcntl($sock,F_SETFL,O_NONBLOCK) or die("fcntl: $!\n");
    log_notice("Connected.");

    return $sock;
}


sub server_send ($$) {
    my($sock, $s) = @_;
    if (syswrite($sock,$s,length($s)) != length($s)) {
	log_err("syswrite: $!"); 
    }
}


sub server_run ($) {
    my($sock) = @_;

    my $state = 'login';

    my($ehid,$ihid);

    $ehid = register_eventhandler('all', sub {
	my($event) = @_;
	my $os = $state;
	if (($event->{Type} eq 'prompt') && ($event->{Line} =~ /^password:/)) {
	    $state = 'password';
	    ui_password(1);
	} elsif (($event->{Type} eq 'prompt') && ($event->{Line} =~ /^-->/)) {
	    $state = 'blurb';
	} elsif (($state eq 'cxna') && ($event->{Line} =~ /^Welcome to/)) {
	    $state = 'cxnb';
	} elsif ($state eq 'cxnb') {
	    $state = 'cxnc';
	} elsif (($state eq 'cxnc')  && ($event->{Type} eq 'prompt')) {
	    $state == 'reviewp';
	} elsif (($state eq 'cxnc') || ($event->{Type} eq 'connected')) {
	    $state = 'connected';
	    deregister_eventhandler('all', $ehid);
	    deregister_user_input_handler($ihid);
	    on_connect($sock);
	}
    });

    $ihid = register_user_input_handler(sub {
	my($ievent) = @_;
	my $os = $state;
	if ($state eq 'password') {
	    $state = 'login';
	    $ievent->{UI} = 0;
	    ui_password(0);
	} elsif ($state eq 'blurb') {
	    $state = 'cxna';
	} elsif ($state eq 'reviewp') {
	    $state = 'connected';
	    deregister_eventhandler('all', $ehid);
	    deregister_user_input_handler($ihid);
	    on_connect($sock);
	}
	return 0;
    });

    set_client_options($sock);

    my $s = IO::Select->new($sock, \*STDIN);

    while (1) {
	foreach ($s->can_read()) {
	    if ($_ == $sock) {
		parse(read_from_server($sock));
	    } elsif ($_ == \*STDIN) {
		foreach (user_accept()) {
		    server_send($sock, $_);
		}
	    }
	}
    }
}


sub set_client_options {
    #
    # Lily is gifted with a multitude of incompatible options.  What I have
    # here seems to work everywhere in use at the moment.  Someday, someone
    # will come along and break everything in the name of progress.  At this
    # point, I will declare lily dead, and get a life.
    #
    # The single, sole option which appears to work everywhere is `leaf'.
    # This gives me command leafing; the server will kindly identify
    # exactly what lines it sends to me are associated with what commands
    # I send to it.  This is insanely useful; I'm amazed it works.  (I had
    # begun to think that the server designers had intentionally designed
    # things to prevent anything useful from being usable.)
    #
    # But, alas, there is a serpent in paradise.  Nobody (and I mean NOBODY)
    # other than lclient is allowed to receive %gs.  This means that signalling
    # is utterly broken by my use of this option.  I therefore shall
    # implement signalling entirely in the client, and to hell with the
    # servers.
    #
    # Another REALLY useful option is `leaf-msg'.  It doesn't work right on
    # 2.2a1 cores.
    #
    # And then there's the `connected' option!  Ah, what I wouldn't do to
    # be able to use IT!
    #

    server_send($sock, "\#\$\# client_version $TL_VERSION\n");
    server_send($sock, "\#\$\# client_name TigerLily\n");
    server_send($sock, "\#\$\# options +leaf-all +leaf\n");
}


sub on_connect ($) {
    my($sock) = @_;

    set_client_options($sock);
}


sub main () {
    show_banner();
    
    # !command handler
    register_user_input_handler(sub {
	my($event) = @_;
	if ($event->{Line} =~ /^\!(.*)/) {
	    user_showline($event->{Line});
	    ui_output(`$1`);
	    return 1;
	}
	return 0;
    });

    # handle /info set command.  
    register_user_input_handler(sub {
	my($event) = @_;
	if ($event->{Line} =~ /^\s*\/info set/i) {
	    my $line = $event->{Line};
	    $line =~ s/\s*\/info set\s*//g;
	    set_info($line);
	}
	return 0;
    });

    my $sock = server_connect($config{server}, $config{port});
    server_run($sock);
}


##############################################################################
sub login {   
    $parse_state="login";
    log_notice("Connecting to $config{server} $config{port}.");
    set_status(server => $config{server},
	       status => "INIT");

    $sock = IO::Socket::INET->new(PeerAddr => $config{server},
				  PeerPort => $config{port},
				  Proto    => 'tcp');                         
    if (! defined($sock)) { log_err("IO::Socket: $!\n"); }
    
    fcntl($sock,F_SETFL,O_NONBLOCK) || log_err("fcntl: $!\n");
    
    set_status(status => "CONN");
    
    log_notice("Connected.");
    
    pass_until("login:",10);
    set_client_options(); # if (!$config{options_after_connect});

    if ($config{login} && $config{pass}) {
	log_info("Sending autologin ($config{login})\n");
	send_to_server("$config{login} $config{pass}\n");
    }

    connect_until("***");
    set_client_options() if ($config{options_after_connect});
    set_status(status => "ONLINE");
    log_info("Connected");
}


# allow the user to type, a nice normal bidirectional connection until we
# see the desired output.
sub connect_until {
    my ($waitfor)=@_;
    my ($str,$t,$u);

    $waitfor=~ s/\*/\\\*/g;
    $waitfor=~ s/\./\\\./g;

    my $s = IO::Select->new();    

    $s->add($sock);
    $s->add(\*STDIN);

    $next_alarm=30; # kicked up by a %connected event or %c command.

    my $end;
    my $pp_token = register_preparser(sub {
	my ($line) = @_;
	$end = 1 if ($line =~ /$waitfor/);
    });

    $last_alarm=time();
    while (1) {
	if (time() > ($last_alarm+$next_alarm)) {
	    alarm_handler();
	}

	@ready=$s->can_read($wakeup);	

	$str="";
	foreach $rs (@ready) {      
	    if ($rs == $sock) {
		parse(read_from_server($rs));
		if ($end) {
		    deregister_preparser($pp_token);
		    return;
		}
		next;
	    }
	    
	    if ($rs == \*STDIN) {
		# check for UI events, deal wid' em.
		while (1) {
		    # get a line of input from the user if it's available.
		    my $line=ui_process();		
		    if (defined($line)) {		    
			my $qline = $line; $qline =~ s/[\<\\]/\\$&/g;

			if ($password_mode) {
			    $password_mode = 0;
			    ui_password(0);
			} else {
			    ui_output("<usersend>" . $qline . "</usersend>");
			}

			if ($line =~ /^\!(.*)/) { 
			    # !command handling
			    ui_output(`$1`); 
			} elsif ($line =~ /^%/) { 
			    # handle client commands
			    client_command($line);
			} elsif ($line =~ /^([^:;]*)[;:]/) {
			    # handle recipient caching for ;
			    exp_set('recips', $1);
			    send_to_server($line . "\n");
			} elsif ($line =~ /^\s*\/info set/i) {
			    # handle /info set command.  
			    $line =~ s/\s*\/info set\s*//g;
			    set_info($line);
			} else {
			    # otherwise, send on to the server.
			    send_to_server($line . "\n");
			}
		    } else {
#			log_debug("line undef"); 
			last;
		    }
		}
		next;
	    }       	
	    
	    log_err("SKY IS FALLING!\n");
	}
    }   
}

# pass through all output from the server until a string is matched.
sub pass_until {
    my ($waitfor,$timeout)=@_;
    my ($t,$str,$matched) = ('', '', 0);

    my $pp_token = register_preparser(sub {
	my ($line) = @_;
	$matched = 1 if ($line =~ /$waitfor/);
    });
    
    my $s = IO::Select->new();

    $s->add($sock);

    my $stime=time();
    my $now=$stime;
    while ((!$matched) && ($now-$stime < $timeout)) {	
	if ($s->can_read($stime+$timeout-$now)) {
	    parse(read_from_server($sock));
	}
	$now=time();
    }

    deregister_preparser($pp_token);

    if (! $matched) {
	log_err("Error waiting for $waitfor, $timeout sec timeout expired.\n");
    }
}


my $crumb = '';
sub read_from_server {
    my ($sock) = @_;

    my $buf;
    if (sysread($sock,$buf,4096) < 1) {
	if ($errno != EAGAIN) {
	    log_err("sysread: $!"); 
	    next;
	}
    }

    return $buf;
}



sub client_command {
    my($command) = @_;

    return if ($command !~ /^(%\w+)\s*(.*)$/);
    my($cmd, $args) = ($1, $2);

    if ($cmd eq '%eval') {
	my $output=eval($args); 
	ui_output($output);
	ui_output($@) if ($@);
    } elsif ($cmd eq '%leaf') {
	cmd_process($args, sub {
	    my($e) = @_;
	    $e->{Line} = 'leaf: ' . $e->{Line};
	});
    } elsif ($cmd eq '%version') {
	ui_output("Tigerlily, version $TL_VERSION");
    } elsif ($cmd eq '%gag') {
	foreach (split /[\s,]+/, $args) {
	    if ($gagged{tolower($_)}) {
		undef $gagged{tolower($_)};
		ui_output("$_ is no longer gagged.");
	    } else {
		$gagged{tolower($_)} = 1;
		ui_output("$_ is gagged.");
	    }
	}
    } else {
	ui_output("?");
	ui_output("? %eval <code>       - evals a chunk o' perl");
	ui_output("? %gag <user>        - gags a user");
	ui_output("?");
    }
}


sub do_how {
    $cli_command="how";
    
    send_to_server("/how\n");
}

sub do_who_me {
    $cli_command="who me";
    
    send_to_server("/who me\n");
}

sub alarm_handler {
    log_debug("alarm handler");

    if ($parse_state eq undef) {
	# we're idle, so we can send these commands.

	log_debug("alarm handler: idle state ok");	
	log_debug("alarm handler: unable to proceed- $cli_command pending") 
	    if $cli_command;
	

	if (! $have_pseudo) {
	    do_who_me() unless $cli_command;
	}
	
	do_how() unless $cli_command;
    } else {
	log_debug("alarm handler: not in idle state");
    }

    if ($have_pseudo) {
	log_debug("alarm handler, set for 300");
	$next_alarm=300;		
    } else {
	log_debug("alarm handler, set for 5");
	$next_alarm=5;
    }

    $last_alarm=time()	
}




sub set_status {
    my %s2=@_;

    foreach (keys %s2) {
	if ($s2{$_} eq "incr") {
	    $status{$_}++;
	} elsif ($s2{$_} eq "decr") {
	    $status{$_}--;
	} else {
	    $status{$_}=$s2{$_}; 
	}
    }


    my @left;
    my $name=$status{pseudo};
    $name .= " [$status{blurb}]" if (defined($status{blurb}));
    push @left, $name if length($name);
    push @left,"Parse: $LC::parse::parse_state" if $debug;
    my @right;
    push @right, "$status{here} Here|$status{away} Away|$status{detached} Detach"
                                     if (defined($status{detached}));
    push @right, $status{server}     if (defined($status{server}));
    push @right, $status{status}     if (defined($status{server}));
    
    my $left=join ' | ',@left;
    my $right=join ' | ',@right;
    my $ll=length($left);
    my $lr=80-$ll;    

    # favor things on the left over the right.
    $fmt="%-$ll.$ll" . "s%$lr.$lr" . "s";
    $status_line=sprintf($fmt,$left,$right);

    $status_line =~ s:\|:<whiteblue>\|</whiteblue>:g;
    $status_line =~ s:ONLINE:<greenblue>ONLINE</greenblue>:;

    # -- MORE -- prompt
    if (length($status{page_status})) {
	$status_line="                                 -- $status{page_status} -- ";
    }
    
    ui_status($status_line);

      
}

sub set_info {
    # rather than using the chee-z line editor in emacs, we fire off an editor
    # to let them edit the /info file.
    my($disc)=@_;
    
    my $EDITOR=$ENV{VISUAL} || $ENV{EDITOR} || "vi";
    
    ui_end();
    unlink ("/tmp/tlily.$$");
    if (@info) {
	open(F,">/tmp/tlily.$$");
	foreach (@info) { chomp; print F "$_\n"; }
	close(F);
    }

    system("$EDITOR /tmp/tlily.$$");
    ui_start();

    if (open(F,"</tmp/tlily.$$")) {
	@info=<F>;
	close(F);
	unlink ("/tmp/tlily.$$");
	my $size=@info;

	$cli_command="info set";
	send_to_server("\#\$\# export_file info $size $disc\n");
    } else {
	log_notice("info buffer file not found.");
    }
    
}

sub show_banner {

    ui_output(qq[
<yellow>     ("`-/")_.-'"``-._ </yellow>
<yellow>      . . `; -._    )-;-,_`)</yellow>          <green>TigerLily $TL_VERSION</green>
<yellow>     (v_,)'  _  )`-.\  ``-'</yellow>             <b>"Feel Free"</b>
<yellow>    _.- _..-_/ / ((.'</yellow>
<yellow>  ((,.-'   ((,/ </yellow>
<b>------------------------------------------------------------------------------</b>
]);
}


1;


