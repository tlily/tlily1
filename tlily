#!/usr/local/bin/perl 
#-w

$TL_VERSION="0.6";

use LC::log; 
use LC::config;
use LC::UI;
use LC::parse;
use LC::Expand;
use Socket;
use Fcntl;
use IO::Socket;
use IO::Select;
use Curses;
$|=1;

# file globals
my $sock;

# globals
$have_pseudo=0;
$last_alarm=0;
$next_alarm=0;
$wakeup=10;     # how often to exit the select loop to do status processing,
                # etc.

## main ##
LC::config::init();
exp_init();


ui_start();
ui_attr('sender','bold');
ui_attr('dest','bold');
if (! $config{mono}) {
    ui_attr('status_line',  'fg:yellow',  'bg:blue',  'bold');
    ui_attr('input_line',   'fg:white',   'bg:black', 'bold');
    ui_attr('text_window',  'fg:white',   'bg:black', 'normal');
    ui_attr('privhdr',      'fg:green',   'bg:black');
    ui_attr('privmsg',      'fg:green',   'bg:black');
    ui_attr('pubhdr',       'fg:cyan',    'bg:black', 'bold');
    ui_attr('pubmsg',       'fg:white',   'bg:black');
    ui_attr('emote',        'fg:cyan',    'bg:black');
    ui_attr('review',       'fg:magenta', 'bg:black');
    ui_attr('whiteblue',    'fg:white',   'bg_blue');
    ui_attr('greenblue',    'fg:green',   'bg_blue',  'bold');
}

tie $page_status, 'LC::status_update', 'page_status';
login();
$SIG{ALRM}=\&foo;
connect_until("*** Disconnected ***");    
log_notice("Exiting.");

END {
    ui_end;
}

##############################################################################
sub login {    
    $parse_state="login";
    log_notice("Connecting to $config{server} $config{port}.");
    set_status(server => $config{server},
	       status => "INIT");

    $sock = IO::Socket::INET->new(PeerAddr => $config{server},
				  PeerPort => $config{port},
				  Proto    => 'tcp');                         
    if (! defined($sock)) { die "IO::Socket: $!\n"; }
    
    fcntl($sock,F_SETFL,O_NONBLOCK) || die "fcntl: $!\n";
    
    set_status(status => "CONN");
    
    log_notice("Connected.");
    
    pass_until("login:",10);
    set_client_options() if (!$config{options_after_connect});

    if ($config{login} && $config{pass}) {
	log_info("Sending autologin ($config{login})\n");
	send_to_server("$config{login} $config{pass}\n");
    }

    connect_until("***");
    set_client_options() if ($config{options_after_connect});
    set_status(status => "ONLINE");
    log_info("Connected");
}


# allow the user to type, a nice normal bidirectional connection until we
# see the desired output.
sub connect_until {
    my ($waitfor)=@_;
    my ($str,$t,$u);
    
    $waitfor=~ s/\*/\\\*/g;
    $waitfor=~ s/\./\\\./g;

    my $s = IO::Select->new();    

    $s->add($sock);
    $s->add(\*STDIN);

    $next_alarm=30; # kicked up by a %connected event or %c command.

    $last_alarm=time();
    while (1) {
	if (time() > ($last_alarm+$next_alarm)) {
	    alarm_handler();
	}

	@ready=$s->can_read($wakeup);	

	$t="";
	$str="";
	foreach $rs (@ready) {      
	    if ($rs == $sock) {
		if (sysread($sock,$t,4096) < 1) { log_err("sysread: $!"); }
		$u=$t;		
		
		$u =~ s/^%.*$//gm;
		# workaround for %recip_regexp at blurb prompt
		$u =~ s/^--> %.*$/--> /gm;

		# NOTE: Should also have code for if we got a partial line
		#       (not in the 4096 buffer, whatever, foo my bar.)
		# non critical, the command will be picked up later, but
		# the user might see part of it. woo.
		
		parse_output($u);    # show it to the user..

		$str .= $t;

		# workaround for %recip_regexp at blurb prompt
		if ( $str =~ /^--> (%.*)$/m ) {
		    parse_servercmd($1);
		    $str =~ s/^--> %.*$/--> /gm;
		} 

		if ( $str =~ /^(%.*)$/m ) {
		    parse_servercmd($1);
		    $str =~ s/^%.*$//gm;
		}

		if ($str =~ /$waitfor/) { return; }
		if ($t eq '\n') { $str=""; }
		next;
	    }
	    
	    if ($rs == \*STDIN) {
		# check for UI events, deal wid' em.
		while (1) {
		    # get a line of input from the user if it's available.
		    $line=ui_process();		
		    if (defined($line)) {		    
			my $qline = $line; $qline =~ s/[\<\>]/\\$&/g;
			ui_output($qline);
			if ($line =~ /^%/) { 
			    # handle client commands
			    $line=~s/^%//g;
			    my $output=eval($line); 
			    ui_output($output);
			    ui_output($@) if ($@);
			} elsif ($line =~ /^([^:;]*)[;:]/) {
			    exp_set('recips', $1);
			    send_to_server("$line\n");
			} else {
			    # otherwise, send on to the server.
			    send_to_server("$line\n");
			}
		    } else {
#			log_debug("line undef"); 
			last;
		    }
		}
		next;
	    }       	
	    
	    log_err("SKY IS FALLING!\n");
	}
    }   
}

# pass through all output from the server until a string is matched.
sub pass_until {
    my ($waitfor,$timeout)=@_;
    my ($t,$str,$matched);
    
    my $s = IO::Select->new();

    $s->add($sock);

    my $stime=time();
    my $now=$stime;
    $t="";
    $str="";
    while ($now-$stime < $timeout) {	
	if ($s->can_read($stime+$timeout-$now)) {
	    if (sysread($sock,$t,1) != 1) { log_err("sysread: $!"); }
	    $str .= $t;
	    
	    if ($str =~ /$waitfor$/) {
		$matched=1;
		last; 
	    }

	    if ($str =~ /\n/) {
		parse_output($str);
		$str = "";
	    }
	}
	$now=time();
    }

    if ($str) { parse_output($str); }
   
    if (! $matched) {
	log_err("Error waiting for $waitfor, $timeout sec timeout expired.\n");
    }
}


sub send_to_server {
    my ($s)=@_;
    
    my $t=$s;
    $t=~s/\n/\[\\n\]/g;
    log_debug("send_to_server: $t");
    if (syswrite($sock,$s,length($s)) != length($s)) {
	log_err("syswrite: $!"); 
    }

}


sub do_how {
    $cli_command="how";
    
    send_to_server("/how\n");
}

sub do_who_me {
    $cli_command="who me";
    
    send_to_server("/who me\n");
}

sub alarm_handler {
    log_debug("alarm handler");

    if ($parse_state eq undef) {
	# we're idle, so we can send these commands.

	log_debug("alarm handler: idle state ok");	
	log_debug("alarm handler: unable to proceed- $cli_command pending") 
	    if $cli_command;
	

	if (! $have_pseudo) {
	    do_who_me() unless $cli_command;
	}
	
	do_how() unless $cli_command;
    } else {
	log_debug("alarm handler: not in idle state");
    }

    if ($have_pseudo) {
	log_debug("alarm handler, set for 300");
	$next_alarm=300;		
    } else {
	log_debug("alarm handler, set for 5");
	$next_alarm=5;
    }

    $last_alarm=time()	
}


sub set_client_options {
    if ($config{spoof_lclient}) {
	log_notice("Setting client options (lclient spoofing)..");
	send_to_server("\#\$\# client_version 0.8b-tiger\n");
	send_to_server("\#\$\# client_name lily\n");
    } else {
	log_notice("Setting client options..");
	send_to_server("\#\$\# client_version $TL_VERSION\n");
	send_to_server("\#\$\# client_name TigerLily\n");
        #The available options are sender, sendgroup,recip_regexp, connected,
        #info_size, usertype, leaf-cmd, leaf-msg, leaf-notify, and prompt.
	#[+-]leaf-all will turn on or off all of the leafing options.
	send_to_server("\#\$\# options +connected +usertype +leaf-msg +leaf-notify +prompt\n");
    }
}


sub set_status {
    my %s2=@_;

    foreach (keys %s2) {
	if ($s2{$_} eq "incr") {
	    $status{$_}++;
	} elsif ($s2{$_} eq "decr") {
	    $status{$_}--;
	} else {
	    $status{$_}=$s2{$_}; 
	}
    }


    my @left;
    my $name=$status{pseudo};
    $name .= "[$status{blurb}]" if (defined($status{blurb}));
    push @left, $name if length($name);
    push @left," -- $status{page_status} -- " 
                                     if (length($status{page_status}));
    push @left,"Parse: $LC::parse::parse_state";
    my @right;
    push @right, "$status{here} Here|$status{away} Away|$status{detached} Detach"
                                     if (defined($status{detached}));
    push @right, $status{server}     if (defined($status{server}));
    push @right, $status{status}     if (defined($status{server}));
    
    my $left=join ' | ',@left;
    my $right=join ' | ',@right;
    my $lr=length($right);
    my $ll=80-$lr;    

    # favor things on the right over the left.
    $fmt="%-$ll.$ll" . "s%$lr.$lr" . "s";
    $status_line=sprintf($fmt,$left,$right);

    $status_line =~ s:\|:<whiteblue>\|</whiteblue>:g;
    $status_line =~ s:ONLINE:<greenblue>ONLINE</greenblue>:;

    
    ui_status($status_line);

      
}


1;


